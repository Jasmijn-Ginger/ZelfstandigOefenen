Use @FunctionalInterface as annotation. This will generate error when compiling (if necessary)

FUNCTION:
receives one value, returns another.
Apply method.
See 1 and 2

It has an extension: ".andThen". Which takes output from function 1 and puts it as input in function 2.
See 3

Extension: ".compose". is like .andThen but than the other way around.
See 4


If function takes on generic type as parameter/argument, it can't have a primitive. There are specialized functions for that.
F.e. Function, IntFunction, LongFunction
To take on generic as parameter, but return primitive, there are again specialized function.
ToIntFunction, ToLongFunction
To take on primitive and return primitive:
IntToDouble, IntToLong, DoubleToInt, DoubleToLong

BiFunction:
takes in two parameters, returns one. Can work with .andThen. Cannot work with .compose.
ToDoubleBiFunction, ToLongBiFunction, ToIntBiFunction, biFunction
See 6 and 7

PREDICATE:
Takes one parameter and returns boolean
extension .test




Streams provide a sequence of elements on which you can perform aggregate operations like filtering, mapping, sorting, and more.
Na stream.map komt altijd .collect