Use @FunctionalInterface as annotation. This will generate error when compiling (if necessary)

FUNCTION:
receives one value, returns another.
Apply method.
See 1 and 2

It has an extension: ".andThen". Which takes output from function 1 and puts it as input in function 2.
See 3

Extension: ".compose". is like .andThen but than the other way around.
See 4


If function takes on generic type as parameter/argument, it can't have a primitive. There are specialized functions for that.
F.e. Function, IntFunction, LongFunction
To take on generic as parameter, but return primitive, there are again specialized function.
ToIntFunction, ToLongFunction
To take on primitive and return primitive:
IntToDouble, IntToLong, DoubleToInt, DoubleToLong

BiFunction:
takes in two parameters, returns one. Can work with .andThen. Cannot work with .compose.
ToDoubleBiFunction, ToLongBiFunction, ToIntBiFunction, biFunction
See 6 and 7

PREDICATE:
Takes one parameter and returns boolean
extension .test
methods: and, or, negate (exclamationmark !)
IntPredicate, LongPredicate, DoublePredicate, BiPredicate
See 8 and 9


SUPPLIER:
doesn't take any argument, but returns result
extension .get
IntSupplier, LongSupplier, DoubleSupplier, BooleanSupplier
See 10, 11, 12

CONSUMER:
takes in argument, returns nothing
extension .accept
methods: andThen
IntConsumer, LongConsumer, DoubleConsumer, ObjIntConsumer, ObjLongConsumer, ObjDoubleConsumer
See 13, 14

UNARYOPERATOR:
extends Function
methods: andThen and compose
IntUnaryOperator, DoubleUnaryOperator, LongUnaryOperator
See 15

BINARYOPERATOR:
extends BiFunction
methods: andThen and compose
IntBinaryOperator, DoubleBinaryOperator, LongBinaryOperator
See 16

MAKE YOUR OWN FUNCTIONAL INTERFACE:
use @FunctionalInterface
voor de rest geen idee

OPTIONALS:
mag nooit null zijn. Wordt voornamelijk gebruikt in testen, zoals hier:
    @Test
    public void whenCreatesEmptyOptional_thenCorrect() {
        Optional<String> empty = Optional.empty();
        assertFalse(empty.isPresent());
    }


RUNNABLES:
functional interface
method: .run()
Doesn't take or give back parameters

CALLABLES:
generic interface
method: .call()
returns generic value V
always needs a throw

ACTIONLISTENER:
is an interface.
method: .actionPerformed()
your code needs to implement the interface







Streams provide a sequence of elements on which you can perform aggregate operations like filtering, mapping, sorting, and more.
Na stream.map komt altijd .collect